
---
title: "Lazy Secrets with Nix"
publishDate: 2025-12-11
description: "Lazy as in evaluation, secrets as in don't leak 'em."
tags: ["nix"]
--- 

I have been enamoured with the idea of a fully declarative home server
recently. Perhaps it is just me,
but I have a fear of forgetting configuration details,
especially since each tool has its own bespoke configuration format.
Sometimes even the files themselves are forgettable places, tucked away 
in the crannies of `/etc`. Most of all, if I need to swap hardware,
I really don't want to reconfigure my entire server _imperatively_.

In this respect, I've found Nix to be a pretty good cure.
I can specify my entire server in one language, from systemd services,
to project dependencies, deployment scripts, or even cron jobs. 
I recently learned something cool about secrets and the Nix expression
language's _lazy_ nature, so I wanted to share it here.

### Secrets

At the beginning of my programming journey I had only a few keys in
`~/.ssh`. Over time this folder grew to a mess of `*.id_rsa` files.
Then secrets started accumulating in project-specific directories, like
API keys, or into `/etc` for SSL certificates. Finally, the issue
compounded as my secrets began migrating to multiple machines. It
became easy for me to lose track of my secrets.
The need for a more robust secret management scheme was clear.

### Sops and Secrets

[Sops](https://github.com/getsops/sops) is a secret manager, and
exists independently of Nix. Like many `*nix` projects, `sops-nix`
exposes some declarative bindings for configuring `sops` using nix.
The basic workflow for using `sops-nix` is as follows.

1. Create a monolithic `secrets.yaml` file somewhere locally. For
   example, an excerpt of mine looks like:

```yaml
cloudflare-dydns-token: |
  CLOUDFLARE_API_TOKEN=cf-token
nix-github-token: |
  gh-token
```

2. Create a `key.age` keypair locally to produce an encrypted
`secrets.yaml.enc` which can be stored in your Nix configuration
repository. (I put mine adjacent to `sops.nix`.)

```bash
sops --encrypt \
     --age "$(cat nix.age.pub)" \
     ./secrets.yaml > ./secrets.yaml.enc
```

3. Configure the `sops-nix` module as follows:

```nix
sops = {
  age.keyFile = "/home/justin/.secrets/nix.age";
  defaultSopsFile = ./secrets.yaml.enc;
  secrets = {
    cloudflare-dydns-token = {
        mode = "0600";
    };
    github-token = {
        path = "/home/justin/.ssh/nix-github-token";
        mode = "0600";
    };
  };
};

```

When building your configuration, sops will read in the encrypted
secrets file, unlock each secret with the `.age` key and write it into
the specified file path. If the `path` attribute is not specified, the
secret will automatically be written to `/run/secrets` on NixOS and
`~/.nix-profile/secrets/` with standalone Nix.

> Note: This doesn't solve the "duplicate your secrets with scp"
problem entirely. It reduces it to a maximum copy of two: one for the
age key, one for the encrypted secrets. It is progress, but maybe
there is a better solution for this.

### Laziness

Once `sops-nix` is configured, you may be asking - doesn't having a
monolithic `secrets.yaml` mean my secrets will be duplicated _in full_
on all my machines? It's probably best for machine-specific secrets to be isolated.
This is where the _lazy evaluation_ of Nix is perfect. When building
your configuration, `sops-nix` will only ever write out the secret to
a file if it is referenced in another attribute. In other words,
secrets are produced at runtime and on demand. 

For example, I only ever need my CloudFlare dynamic DNS token on one
server. So long as `sops.secrets.cloudflare-dydns-token` is only
referenced in this server's configuration, it will never be evaluated
on others. My homeserver is called `bee` (because it is a BeeLink
U59).

```nix
// bee.nix
{ config, pkgs, ... }:

{
  imports = [
    ../modules/nixos/base.nix
    ../programs/sops/sops.nix
  ];

  services.cloudflare-dyndns = {
    enable = true;
    domains = [
        "justinmeimar.com"
    ];
    apiTokenFile = config.sops.secrets.cloudflare-dydns-token.path;
    proxied = true;
  };
}
```

Now, if I ever want to switch the hardware for my home server, all I
have to do is install Nix, copy over some secrets, and a systemd
service to manage dynamic DNS will set itself up instantly!

#### Conclusion

I'm not an expert on Nix, but if you aren't either, I hope this may
have given you an impression of what is possible, and why the
declarative dream is a beautiful one. This is my first blog post, so thank
you for reading this far!

