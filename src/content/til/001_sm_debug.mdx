---
title: "JS Debugging API in SM"
publishDate: 2026-02-06
description: "JavaScript can Debug JavaScript at Runtime."
tags: ["til", "sm"]
---

Dynamic languages can expose runtime debugging APIs. For example,
`pdb` lets a python program debug itself. For SpiderMonkey, an
equivalent mechanism is provided for a JavaScript program to debug
itself via the `Debugger` object.

This example shows the creation of a Debugger at runtime. We bind
`this`, the global JS object, as the debugee, the "thing being
debugged," while the debugger object itself lives in a separate
compartment. This detail is essential, since it imposes the debugger
be created in a memory and garbage collection space logically
separated from other compartments. Otherwise, we could trigger an
infinite recursion of the debugger debugging itself.

```js
// Debugger must live in separate global to avoid observing itself.
// Specifically, we put it in a separate "compartment" - an isolated
// memory and garbage collection boundary.
var debuggerGlobal = newGlobal({newCompartment: true});
debuggerGlobal.debuggeeGlobal = this;
// The function we want to set a debugger event in.
function factorial(n) {
    if (n <= 1) {
        // Trigger a trap which gets caught by the debugger.
        debugger;
        return 1;
    }
    return n * factorial(n - 1);
}
// Evaluates our debugger hook, wrapped in an IIFE, in the
// debuggers compartment.
debuggerGlobal.eval("(" + function() {
    var dbg = new Debugger(debuggeeGlobal);
    // Hook to fire on debugger statements
    dbg.onDebuggerStatement = function(frame) {
      for (var f = frame; f; f = f.older) {
        print(f.callee?.name);
      }
    };
} + ")();");
factorial(5);
```
Once we are in a debug hook, we can access the frame of the function
which was trapped and inspect it as if it were regular data. We can
walk the stack frame, observe the functions and inspect locals. A
debugging API such as this is super useful for writing profilers and
other tooling which requires a program to characterize it's own
behaviour.

Unlike debuggers such as `gdb`, which debug a program by spawning a
child process and handling software traps, the runtime debugginer
interface exists in the exact same process as the main program
execution. Debugging instrumentation is toggled on and off by
[patching the JIT code](https://searchfox.org/firefox-main/rev/b824aa1f1416b2e3675f7561cb58f5568f4f156a/js/src/jit/BaselineCodeGen.cpp#5099).

